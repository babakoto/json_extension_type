// ignore_for_file: avoid_print

import 'dart:io';
import 'package:json_extension_type/models.dart';
import 'package:json_extension_type/parser.dart';
import 'package:json_extension_type/code_generator.dart';

class JsonExtensionGenerator {
  void generate(String libPath) {
    print('üîç Searching for _model.dart files in $libPath...\n');

    final modelsDir = Directory(libPath);
    if (!modelsDir.existsSync()) {
      throw Exception('Directory $libPath does not exist');
    }

    final modelFiles = modelsDir
        .listSync(recursive: true)
        .whereType<File>()
        .where((file) => file.path.endsWith('_model.dart'))
        .toList();

    if (modelFiles.isEmpty) {
      print('‚ùå No _model.dart files found');
      return;
    }

    print('‚úÖ Found ${modelFiles.length} _model.dart file(s)\n');

    for (final modelFile in modelFiles) {
      print('üìù Processing: ${modelFile.path}');
      _generateExtensionForModel(modelFile);
    }
  }

  void _generateExtensionForModel(File modelFile) {
    final content = modelFile.readAsStringSync();
    final parser = ModelParser();
    final codeGen = CodeGenerator();

    // Parse all models (typedefs + classes)
    final models = parser.parseAllModels(content);

    if (models.isEmpty) {
      print('   ‚ö†Ô∏è  No typedef or class found');
      return;
    }

    // Detect enums in the file
    final enums = parser.parseEnums(content);
    final enumsWithValues = parser.parseEnumsWithValues(content);

    // Check if extensions already exist
    final hasExtensions = content.contains('extension type ');

    String newContent;
    if (hasExtensions) {
      // Remove old extensions and regenerate
      newContent = _removeOldExtensions(content);
    } else {
      newContent = content;
    }

    final buffer = StringBuffer();
    buffer.write(newContent);

    // Add empty line if file doesn't end with one
    if (!newContent.endsWith('\n')) {
      buffer.writeln();
    }
    if (!newContent.trimRight().endsWith('\n\n')) {
      buffer.writeln();
    }

    // Add generated code comment header
    buffer.writeln('// Generated by JSON Extension Type (JET)');
    buffer.writeln('// Do not modify manually');
    buffer.writeln('// Run "jet generate" to update');
    buffer.writeln();

    // Generate extension type for each model (typedef or class)
    for (final model in models) {
      buffer.writeln(codeGen.generateExtensionType(model, enums, enumsWithValues));
      buffer.writeln();
    }

    final finalContent = buffer.toString();
    modelFile.writeAsStringSync(finalContent);

    print('   ‚úÖ Extensions added to: ${modelFile.path}');
  }

  String _removeOldExtensions(String content) {
    // Check if there's generated code marker
    final generatedMarker = '// Generated by JSON Extension Type (JET)';
    final markerIndex = content.indexOf(generatedMarker);
    
    if (markerIndex != -1) {
      // Remove everything from the marker onwards
      return content.substring(0, markerIndex).trimRight();
    }
    
    // Fallback: Find the last typedef or class
    final lastTypedefMatch = RegExp(
      r'typedef\s+\w+\s*=\s*\(\{[^}]+\}\);',
      multiLine: true,
      dotAll: true,
    ).allMatches(content).lastOrNull;

    final lastClassMatch = RegExp(
      r'class\s+\w+\s*\{[^}]*\}',
      multiLine: true,
      dotAll: true,
    ).allMatches(content).lastOrNull;

    // Find which one comes last
    int? lastPosition;
    
    if (lastTypedefMatch != null) {
      lastPosition = lastTypedefMatch.end;
    }
    
    if (lastClassMatch != null && 
        (lastPosition == null || lastClassMatch.end > lastPosition)) {
      lastPosition = lastClassMatch.end;
    }

    if (lastPosition != null) {
      return content.substring(0, lastPosition);
    }

    return content;
  }
}

